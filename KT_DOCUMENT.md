# ğŸ“– nestjs-api-connector - Knowledge Transfer

## ğŸš€ Overview

**nestjs-api-connector** is a dynamic API integration library for NestJS. It acts as a "Connector" or "Bridge" layer that sits between your application and external APIs. Instead of hardcoding API calls, you define them as **data configuration** (JSON).

### ğŸŒŸ Key Features

1.  **Dynamic Configuration**: Define API calls, method updates, and mappings in the database.
2.  **No Code Changes**: Add new integrations without deploying new code.
3.  **Authentication Handlers**: Built-in support for Bearer Auth, Basic Auth, API Key, etc.
4.  **Resilience**: Centralized logging, auditing, and error handling.
5.  **Database Agnostic**: Core library ignores the database (uses Repository Pattern).
6.  **TypeORM Ready**: Optional TypeORM implementations included out-of-the-box.
7.  **JSONPath Transformations**: Transform input/output payloads using JSONPath.
8.  **Validation**: JSON Schema validation for inputs.

---

## ğŸ—ï¸ Architecture

The library follows a modular architecture:

**Modules:**
*   `ConnectorModule`: The main module.
*   `TransformerService`: Handles JSON transformation (Data Mapping).
*   `TargetApiCaller`: Makes the actual HTTP calls (Axios wrapper).
*   `MappingRegistryService`: Loads configuration from the repository.

**Interfaces (The Contract):**
*   `IMappingRepository`: Interface for fetching configuration.
*   `IAuditRepository`: Interface for saving logs.

**Implementations (Default):**
*   `TypeOrmMappingRepository`: Included implementation for PostgreSQL/TypeORM.
*   `TypeOrmAuditRepository`: Included implementation for PostgreSQL/TypeORM.

---

## ğŸ› ï¸ Usage Guide

### 1. Installation

```bash
npm install nestjs-api-connector
```

### 2. Configuration (`app.module.ts`)

```typescript
import { ConnectorModule, TypeOrmMappingRepository, TypeOrmAuditRepository, IntegrationMappingEntity, ConnectorAuditEntity } from 'nestjs-api-connector';
import { DataSource } from 'typeorm';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      // connection options...
      entities: [
        IntegrationMappingEntity, 
        // ConnectorAuditEntity, // Optional: Only if using DB Auditing
        // ... your other app entities
      ],
      synchronize: true, // Auto-create tables (Dev only)
    }),
    
    // Configure Connector
    ConnectorModule.forRootAsync({
      inject: [DataSource],
      useFactory: (dataSource: DataSource) => ({
        mappingRepository: new TypeOrmMappingRepository(dataSource.getRepository(IntegrationMappingEntity)),
        // Audit is now optional (Defaults to Console Logger)
      }),
    }),
  ],
})
export class AppModule {}
```

### 3. Calling an API

```typescript
constructor(private connector: ConnectorEngine) {}

async syncData() {
  const result = await this.connector.executeConnector(
    'my-connector-name', // ID or Name from Database
    { someInput: 'value' } // Payload
  );
}
```

---

## ğŸ§ª Verified Scenarios

We have verified the library with the following live tests:

| Feature | Connector Key | Description | Status |
| :--- | :--- | :--- | :--- |
| **GET Request** | `jsonplaceholder-users` | Fetch list, transform via Custom JS | âœ… PASS |


---

## ğŸ“‚ Project Structure

```
src/
â”œâ”€â”€ connector/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ connector-engine.service.ts  # Core Logic
â”‚   â”‚   â”œâ”€â”€ target-api-caller.service.ts # HTTP Client
â”‚   â”‚   â””â”€â”€ transformer.service.ts       # JQ/JSONPath Logic
â”‚   â”œâ”€â”€ repositories/                    # TypeORM Implementations
â”‚   â”œâ”€â”€ entities/                        # TypeORM Entities
â”‚   â””â”€â”€ interfaces/                      # Public Interfaces
â””â”€â”€ index.ts                             # Public API Exports
```

## ğŸ“ Next Steps

1.  **Publish**: Run `npm publish` to push to NPM.
2.  **Integrate**: Use in your main IIRM application.
3.  **Scale**: Add more connectors to the `integration_mappings_config` table.

---
*Document generated by Antigravity AI*
